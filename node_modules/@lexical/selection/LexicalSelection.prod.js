/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

"use strict";var e=require("lexical");function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var n=t((function(e){const t=new URLSearchParams;t.append("code",e);for(let e=1;e<arguments.length;e++)t.append("v",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const o=new Map;function l(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function s(e){const t=e.parentNode;if(null==t)throw new Error("Should never happen");return[t,Array.from(t.childNodes).indexOf(e)]}function r(e){const t={};if(!e)return t;const n=e.split(";");for(const e of n)if(""!==e){const[n,o]=e.split(/:([^]+)/);n&&o&&(t[n.trim()]=o.trim())}return t}function i(e){let t=o.get(e);return void 0===t&&(t=r(e),o.set(e,t)),t}function c(e){let t="";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}function d(t,n,o){let l=n.getNode(),s=o;if(e.$isElementNode(l)){const e=l.getDescendantByIndex(n.offset);null!==e&&(l=e)}for(;s>0&&null!==l;){if(e.$isElementNode(l)){const e=l.getLastDescendant();null!==e&&(l=e)}let o=l.getPreviousSibling(),r=0;if(null===o){let e=l.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){o=null;break}t=e.getPreviousSibling()}null!==e&&(r=e.isInline()?0:2,o=t)}let i=l.getTextContent();""===i&&e.$isElementNode(l)&&!l.isInline()&&(i="\n\n");const c=i.length;if(!e.$isTextNode(l)||s>=c){const t=l.getParent();l.remove(),null==t||0!==t.getChildrenSize()||e.$isRootNode(t)||t.remove(),s-=c+r,l=o}else{const o=l.getKey(),r=t.getEditorState().read((()=>{const t=e.$getNodeByKey(o);return e.$isTextNode(t)&&t.isSimpleText()?t.getTextContent():null})),d=c-s,f=i.slice(0,d);if(null!==r&&r!==i){const t=e.$getPreviousSelection();let n=l;if(l.isSimpleText())l.setTextContent(r);else{const t=e.$createTextNode(r);l.replace(t),n=t}if(e.$isRangeSelection(t)&&t.isCollapsed()){const e=t.anchor.offset;n.select(e,e)}}else if(l.isSimpleText()){const e=n.key===o;let t=n.offset;t<s&&(t=c);const r=e?t-s:0,i=e?t:d;if(e&&0===r){const[e]=l.splitText(r,i);e.remove()}else{const[,e]=l.splitText(r,i);e.remove()}}else{const t=e.$createTextNode(f);l.replace(t)}s=0}}}function f(e,t){const n=i("getStyle"in e?e.getStyle():e.style),l=Object.entries(t).reduce(((t,[o,l])=>("function"==typeof l?t[o]=l(n[o],e):null===l?delete t[o]:t[o]=l,t)),{...n}||{}),s=c(l);e.setStyle(s),o.set(s,l)}function a(t){const n=e.$getSelection();if(!e.$isRangeSelection(n))return;const o=n.getNodes(),l=o.length,{anchor:s,focus:r}=n,i=l-1;let c=o[0],d=o[i];const f=c.getTextContent().length,a=r.offset;let g=s.offset;const u=s.isBefore(r);let p=u?g:a,h=u?a:g;const $=u?s.type:r.type,m=u?r.type:s.type,x=u?r.key:s.key;if(e.$isTextNode(c)&&p===f){const t=c.getNextSibling();e.$isTextNode(t)&&(g=0,p=0,c=t)}if(1===o.length){if(e.$isTextNode(c)&&c.canHaveFormat()){if(p="element"===$?0:g>a?a:g,h="element"===m?f:g>a?g:a,p===h)return;if(e.$isTokenOrSegmented(c)||0===p&&h===f)t(c),c.select(p,h);else{const e=c.splitText(p,h),n=0===p?e[0]:e[1];t(n),n.select(0,h-p)}}}else{if(e.$isTextNode(c)&&p<c.getTextContentSize()&&c.canHaveFormat()&&(0===p||e.$isTokenOrSegmented(c)||(c=c.splitText(p)[1],p=0,u?s.set(c.getKey(),p,"text"):r.set(c.getKey(),p,"text")),t(c)),e.$isTextNode(d)&&d.canHaveFormat()){const n=d.getTextContent().length;d.__key!==x&&0!==h&&(h=n),h===n||e.$isTokenOrSegmented(d)||([d]=d.splitText(h)),0===h&&"element"!==m||t(d)}for(let n=1;n<i;n++){const l=o[n],s=l.getKey();e.$isTextNode(l)&&l.canHaveFormat()&&s!==c.getKey()&&s!==d.getKey()&&!l.isToken()&&t(l)}}}function g(e){return e.getNode().isAttached()}function u(t){let n=t;for(;null!==n&&!e.$isRootOrShadowRoot(n);){const e=n.getLatest(),t=n.getParent();0===e.getChildrenSize()&&n.remove(!0),n=t}}function p(t,o,l,s,r=null){if(0===o.length)return;const i=o[0],c=new Map,d=[];let f=e.$isElementNode(i)?i:i.getParentOrThrow();f.isInline()&&(f=f.getParentOrThrow());let a=!1;for(;null!==f;){const t=f.getPreviousSibling();if(null!==t){f=t,a=!0;break}if(f=f.getParentOrThrow(),e.$isRootOrShadowRoot(f))break}const p=new Set;for(let t=0;t<l;t++){const n=o[t];e.$isElementNode(n)&&0===n.getChildrenSize()&&p.add(n.getKey())}const h=new Set;for(let t=0;t<l;t++){const l=o[t];let r=l.getParent();if(null!==r&&r.isInline()&&(r=r.getParent()),null!==r&&e.$isLeafNode(l)&&!h.has(l.getKey())){const t=r.getKey();if(void 0===c.get(t)){const n=s();n.setFormat(r.getFormatType()),n.setIndent(r.getIndent()),d.push(n),c.set(t,n),r.getChildren().forEach((t=>{n.append(t),h.add(t.getKey()),e.$isElementNode(t)&&t.getChildrenKeys().forEach((e=>h.add(e)))})),u(r)}}else if(p.has(l.getKey())){e.$isElementNode(l)||n(179);const t=s();t.setFormat(l.getFormatType()),t.setIndent(l.getIndent()),d.push(t),l.remove(!0)}}if(null!==r)for(let e=0;e<d.length;e++){const t=d[e];r.append(t)}let $=null;if(e.$isRootOrShadowRoot(f))if(a)if(null!==r)f.insertAfter(r);else for(let e=d.length-1;e>=0;e--){const t=d[e];f.insertAfter(t)}else{const t=f.getFirstChild();if(e.$isElementNode(t)&&(f=t),null===t)if(r)f.append(r);else for(let e=0;e<d.length;e++){const t=d[e];f.append(t),$=t}else if(null!==r)t.insertBefore(r);else for(let e=0;e<d.length;e++){const n=d[e];t.insertBefore(n),$=n}}else if(r)f.insertAfter(r);else for(let e=d.length-1;e>=0;e--){const t=d[e];f.insertAfter(t),$=t}const m=e.$getPreviousSelection();e.$isRangeSelection(m)&&g(m.anchor)&&g(m.focus)?e.$setSelection(m.clone()):null!==$?$.selectEnd():t.dirty=!0}function h(e,t,n,o){e.modify(t?"extend":"move",n,o)}function $(t){const n=t.anchor.getNode();return"rtl"===(e.$isRootNode(n)?n:n.getParentOrThrow()).getDirection()}function m(e,t,n){const o=i(e.getStyle());return null!==o&&o[t]||n}const x=d;exports.$cloneWithProperties=e.$cloneWithProperties,exports.$selectAll=e.$selectAll,exports.$addNodeStyle=function(e){const t=e.getStyle(),n=r(t);o.set(t,n)},exports.$forEachSelectedTextNode=a,exports.$getSelectionStyleValueForProperty=function(t,n,o=""){let l=null;const s=t.getNodes(),r=t.anchor,c=t.focus,d=t.isBackward(),f=d?c.offset:r.offset,a=d?c.getNode():r.getNode();if(e.$isRangeSelection(t)&&t.isCollapsed()&&""!==t.style){const e=i(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<s.length;t++){const r=s[t];if((0===t||0!==f||!r.is(a))&&e.$isTextNode(r)){const e=m(r,n,o);if(null===l)l=e;else if(l!==e){l="";break}}}return null===l?o:l},exports.$isAtNodeEnd=function(t){if("text"===t.type)return t.offset===t.getNode().getTextContentSize();const o=t.getNode();return e.$isElementNode(o)||n(177),t.offset===o.getChildrenSize()},exports.$isParentElementRTL=$,exports.$moveCaretSelection=h,exports.$moveCharacter=function(e,t,n){const o=$(e);h(e,t,n?!o:o,"character")},exports.$patchStyleText=function(t,n){t.isCollapsed()&&e.$isRangeSelection(t)?f(t,n):a((e=>{f(e,n)}))},exports.$setBlocksType=function(t,n){if(null===t)return;const o=t.getStartEndPoints(),l=o?o[0]:null,s=t.is(e.$getSelection())&&t.isCollapsed();if(null!==l&&"root"===l.key){const t=n(),o=e.$getRoot(),l=o.getFirstChild();return l?l.replace(t,!0):o.append(t),void(s&&t.select())}const r=t.getNodes().filter(e.INTERNAL_$isBlock).filter(e.$isElementNode),i=l?function(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}(l.getNode(),e.INTERNAL_$isBlock):null;e.$isElementNode(i)&&!r.find((e=>e.is(i)))&&r.push(i);for(const e of r){const t=n();t.setFormat(e.getFormatType()),t.setIndent(e.getIndent()),e.replace(t,!0),e.is(i)&&s&&t.select()}},exports.$shouldOverrideDefaultCharacterSelection=function(t,n){const o=e.$getAdjacentNode(t.focus,n);return e.$isDecoratorNode(o)&&!o.isIsolated()||e.$isElementNode(o)&&!o.isInline()&&!o.canBeEmpty()},exports.$sliceSelectedTextNodeContent=function(t,n){const o=t.getStartEndPoints();if(n.isSelected(t)&&!n.isSegmented()&&!n.isToken()&&null!==o){const[l,s]=o,r=t.isBackward(),i=l.getNode(),c=s.getNode(),d=n.is(i),f=n.is(c);if(d||f){const[o,l]=e.$getCharacterOffsets(t),s=i.is(c),d=n.is(r?c:i),f=n.is(r?i:c);let a,g=0;if(s)g=o>l?l:o,a=o>l?o:l;else if(d){g=r?l:o,a=void 0}else if(f){g=0,a=r?o:l}return n.__text=n.__text.slice(g,a),n}}return n},exports.$trimTextContentFromAnchor=d,exports.$wrapNodes=function(t,n,o=null){const l=t.getStartEndPoints(),s=l?l[0]:null,r=t.getNodes(),i=r.length;if(null!==s&&(0===i||1===i&&"element"===s.type&&0===s.getNode().getChildrenSize())){const e="text"===s.type?s.getNode().getParentOrThrow():s.getNode(),t=e.getChildren();let l=n();return l.setFormat(e.getFormatType()),l.setIndent(e.getIndent()),t.forEach((e=>l.append(e))),o&&(l=o.append(l)),void e.replace(l)}let c=null,d=[];for(let l=0;l<i;l++){const s=r[l];e.$isRootOrShadowRoot(s)?(p(t,d,d.length,n,o),d=[],c=s):null===c||null!==c&&e.$hasAncestor(s,c)?d.push(s):(p(t,d,d.length,n,o),d=[s])}p(t,d,d.length,n,o)},exports.createDOMRange=function(t,n,o,r,i){const c=n.getKey(),d=r.getKey(),f=document.createRange();let a=t.getElementByKey(c),g=t.getElementByKey(d),u=o,p=i;if(e.$isTextNode(n)&&(a=l(a)),e.$isTextNode(r)&&(g=l(g)),void 0===n||void 0===r||null===a||null===g)return null;"BR"===a.nodeName&&([a,u]=s(a)),"BR"===g.nodeName&&([g,p]=s(g));const h=a.firstChild;a===g&&null!=h&&"BR"===h.nodeName&&0===u&&0===p&&(p=1);try{f.setStart(a,u),f.setEnd(g,p)}catch(e){return null}return!f.collapsed||u===p&&c===d||(f.setStart(g,p),f.setEnd(a,u)),f},exports.createRectsFromDOMRange=function(e,t){const n=e.getRootElement();if(null===n)return[];const o=n.getBoundingClientRect(),l=getComputedStyle(n),s=parseFloat(l.paddingLeft)+parseFloat(l.paddingRight),r=Array.from(t.getClientRects());let i,c=r.length;r.sort(((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n}));for(let e=0;e<c;e++){const t=r[e],n=i&&i.top<=t.top&&i.top+i.height>t.top&&i.left+i.width>t.left,l=t.width+s===o.width;n||l?(r.splice(e--,1),c--):i=t}return r},exports.getCSSFromStyleObject=c,exports.getStyleObjectFromCSS=i,exports.trimTextContentFromAnchor=x;
